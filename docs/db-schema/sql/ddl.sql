-- DROP SCHEMA public;

CREATE SCHEMA public AUTHORIZATION homebox;

-- DROP SEQUENCE public.auth_roles_id_seq;

CREATE SEQUENCE public.auth_roles_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 9223372036854775807
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE public.goose_db_version_id_seq;

CREATE SEQUENCE public.goose_db_version_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;-- public.goose_db_version definition

-- Drop table

-- DROP TABLE public.goose_db_version;

CREATE TABLE public.goose_db_version (
	id int4 GENERATED BY DEFAULT AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
	version_id int8 NOT NULL,
	is_applied bool NOT NULL,
	tstamp timestamp DEFAULT now() NOT NULL,
	CONSTRAINT goose_db_version_pkey PRIMARY KEY (id)
);


-- public."groups" definition

-- Drop table

-- DROP TABLE public."groups";

CREATE TABLE public."groups" (
	id uuid NOT NULL,
	created_at timestamptz NOT NULL,
	updated_at timestamptz NOT NULL,
	"name" varchar NOT NULL,
	currency varchar DEFAULT 'usd'::character varying NOT NULL,
	CONSTRAINT groups_pkey PRIMARY KEY (id)
);


-- public.group_invitation_tokens definition

-- Drop table

-- DROP TABLE public.group_invitation_tokens;

CREATE TABLE public.group_invitation_tokens (
	id uuid NOT NULL,
	created_at timestamptz NOT NULL,
	updated_at timestamptz NOT NULL,
	"token" bytea NOT NULL,
	expires_at timestamptz NOT NULL,
	uses int8 DEFAULT 0 NOT NULL,
	group_invitation_tokens uuid NULL,
	CONSTRAINT group_invitation_tokens_pkey PRIMARY KEY (id),
	CONSTRAINT group_invitation_tokens_groups_invitation_tokens FOREIGN KEY (group_invitation_tokens) REFERENCES public."groups"(id) ON DELETE CASCADE
);
CREATE UNIQUE INDEX group_invitation_tokens_token_key ON public.group_invitation_tokens USING btree (token);


-- public.labels definition

-- Drop table

-- DROP TABLE public.labels;

CREATE TABLE public.labels (
	id uuid NOT NULL,
	created_at timestamptz NOT NULL,
	updated_at timestamptz NOT NULL,
	"name" varchar NOT NULL,
	description varchar NULL,
	color varchar NULL,
	group_labels uuid NOT NULL,
	CONSTRAINT labels_pkey PRIMARY KEY (id),
	CONSTRAINT labels_groups_labels FOREIGN KEY (group_labels) REFERENCES public."groups"(id) ON DELETE CASCADE
);


-- public.locations definition

-- Drop table

-- DROP TABLE public.locations;

CREATE TABLE public.locations (
	id uuid NOT NULL,
	created_at timestamptz NOT NULL,
	updated_at timestamptz NOT NULL,
	"name" varchar NOT NULL,
	description varchar NULL,
	group_locations uuid NOT NULL,
	location_children uuid NULL,
	CONSTRAINT locations_pkey PRIMARY KEY (id),
	CONSTRAINT locations_groups_locations FOREIGN KEY (group_locations) REFERENCES public."groups"(id) ON DELETE CASCADE,
	CONSTRAINT locations_locations_children FOREIGN KEY (location_children) REFERENCES public.locations(id) ON DELETE SET NULL
);


-- public.users definition

-- Drop table

-- DROP TABLE public.users;

CREATE TABLE public.users (
	id uuid NOT NULL,
	created_at timestamptz NOT NULL,
	updated_at timestamptz NOT NULL,
	"name" varchar NOT NULL,
	email varchar NOT NULL,
	"password" varchar NOT NULL,
	is_superuser bool DEFAULT false NOT NULL,
	superuser bool DEFAULT false NOT NULL,
	"role" varchar DEFAULT 'user'::character varying NOT NULL,
	activated_on timestamptz NULL,
	group_users uuid NOT NULL,
	CONSTRAINT users_pkey PRIMARY KEY (id),
	CONSTRAINT users_groups_users FOREIGN KEY (group_users) REFERENCES public."groups"(id) ON DELETE CASCADE
);
CREATE UNIQUE INDEX users_email_key ON public.users USING btree (email);


-- public.auth_tokens definition

-- Drop table

-- DROP TABLE public.auth_tokens;

CREATE TABLE public.auth_tokens (
	id uuid NOT NULL,
	created_at timestamptz NOT NULL,
	updated_at timestamptz NOT NULL,
	"token" bytea NOT NULL,
	expires_at timestamptz NOT NULL,
	user_auth_tokens uuid NULL,
	CONSTRAINT auth_tokens_pkey PRIMARY KEY (id),
	CONSTRAINT auth_tokens_users_auth_tokens FOREIGN KEY (user_auth_tokens) REFERENCES public.users(id) ON DELETE CASCADE
);
CREATE UNIQUE INDEX auth_tokens_token_key ON public.auth_tokens USING btree (token);


-- public.items definition

-- Drop table

-- DROP TABLE public.items;

CREATE TABLE public.items (
	id uuid NOT NULL,
	created_at timestamptz NOT NULL,
	updated_at timestamptz NOT NULL,
	"name" varchar NOT NULL,
	description varchar NULL,
	import_ref varchar NULL,
	notes varchar NULL,
	quantity int8 DEFAULT 1 NOT NULL,
	insured bool DEFAULT false NOT NULL,
	archived bool DEFAULT false NOT NULL,
	asset_id int8 DEFAULT 0 NOT NULL,
	serial_number varchar NULL,
	model_number varchar NULL,
	manufacturer varchar NULL,
	lifetime_warranty bool DEFAULT false NOT NULL,
	warranty_expires timestamptz NULL,
	warranty_details varchar NULL,
	purchase_time timestamptz NULL,
	purchase_from varchar NULL,
	purchase_price float8 DEFAULT 0 NOT NULL,
	sold_time timestamptz NULL,
	sold_to varchar NULL,
	sold_price float8 DEFAULT 0 NOT NULL,
	sold_notes varchar NULL,
	group_items uuid NOT NULL,
	item_children uuid NULL,
	location_items uuid NULL,
	sync_child_items_locations bool DEFAULT false NOT NULL,
	CONSTRAINT items_pkey PRIMARY KEY (id),
	CONSTRAINT items_groups_items FOREIGN KEY (group_items) REFERENCES public."groups"(id) ON DELETE CASCADE,
	CONSTRAINT items_items_children FOREIGN KEY (item_children) REFERENCES public.items(id) ON DELETE SET NULL,
	CONSTRAINT items_locations_items FOREIGN KEY (location_items) REFERENCES public.locations(id) ON DELETE CASCADE
);
CREATE INDEX idx_items_group_parent_active ON public.items USING btree (group_items, item_children, archived);
CREATE INDEX idx_items_location_parent ON public.items USING btree (location_items, item_children) WHERE (archived = false);
CREATE INDEX idx_items_name_parent_search ON public.items USING btree (name, item_children) WHERE (archived = false);
CREATE INDEX idx_items_parent_child ON public.items USING btree (item_children) WHERE (item_children IS NOT NULL);
CREATE INDEX idx_items_root_items ON public.items USING btree (group_items, location_items) WHERE ((item_children IS NULL) AND (archived = false));
CREATE INDEX item_archived ON public.items USING btree (archived);
CREATE INDEX item_asset_id ON public.items USING btree (asset_id);
CREATE INDEX item_manufacturer ON public.items USING btree (manufacturer);
CREATE INDEX item_model_number ON public.items USING btree (model_number);
CREATE INDEX item_name ON public.items USING btree (name);
CREATE INDEX item_serial_number ON public.items USING btree (serial_number);


-- public.label_items definition

-- Drop table

-- DROP TABLE public.label_items;

CREATE TABLE public.label_items (
	label_id uuid NOT NULL,
	item_id uuid NOT NULL,
	CONSTRAINT label_items_pkey PRIMARY KEY (label_id, item_id),
	CONSTRAINT label_items_item_id FOREIGN KEY (item_id) REFERENCES public.items(id) ON DELETE CASCADE,
	CONSTRAINT label_items_label_id FOREIGN KEY (label_id) REFERENCES public.labels(id) ON DELETE CASCADE
);


-- public.maintenance_entries definition

-- Drop table

-- DROP TABLE public.maintenance_entries;

CREATE TABLE public.maintenance_entries (
	id uuid NOT NULL,
	created_at timestamptz NOT NULL,
	updated_at timestamptz NOT NULL,
	"date" timestamptz NULL,
	scheduled_date timestamptz NULL,
	"name" varchar NOT NULL,
	description varchar NULL,
	"cost" float8 DEFAULT 0 NOT NULL,
	item_id uuid NOT NULL,
	CONSTRAINT maintenance_entries_pkey PRIMARY KEY (id),
	CONSTRAINT maintenance_entries_items_maintenance_entries FOREIGN KEY (item_id) REFERENCES public.items(id) ON DELETE CASCADE
);


-- public.notifiers definition

-- Drop table

-- DROP TABLE public.notifiers;

CREATE TABLE public.notifiers (
	id uuid NOT NULL,
	created_at timestamptz NOT NULL,
	updated_at timestamptz NOT NULL,
	"name" varchar NOT NULL,
	url varchar NOT NULL,
	is_active bool DEFAULT true NOT NULL,
	group_id uuid NOT NULL,
	user_id uuid NOT NULL,
	CONSTRAINT notifiers_pkey PRIMARY KEY (id),
	CONSTRAINT notifiers_groups_notifiers FOREIGN KEY (group_id) REFERENCES public."groups"(id) ON DELETE CASCADE,
	CONSTRAINT notifiers_users_notifiers FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE
);
CREATE INDEX notifier_group_id ON public.notifiers USING btree (group_id);
CREATE INDEX notifier_group_id_is_active ON public.notifiers USING btree (group_id, is_active);
CREATE INDEX notifier_user_id ON public.notifiers USING btree (user_id);
CREATE INDEX notifier_user_id_is_active ON public.notifiers USING btree (user_id, is_active);


-- public.attachments definition

-- Drop table

-- DROP TABLE public.attachments;

CREATE TABLE public.attachments (
	id uuid NOT NULL,
	created_at timestamptz NOT NULL,
	updated_at timestamptz NOT NULL,
	"type" varchar DEFAULT 'attachment'::character varying NOT NULL,
	"primary" bool DEFAULT false NOT NULL,
	item_attachments uuid NULL,
	title varchar DEFAULT ''::character varying NOT NULL,
	"path" varchar DEFAULT ''::character varying NOT NULL,
	attachment_thumbnail uuid NULL,
	mime_type varchar DEFAULT 'application/octet-stream'::character varying NULL,
	CONSTRAINT attachments_no_self_reference CHECK ((id <> attachment_thumbnail)),
	CONSTRAINT attachments_pkey PRIMARY KEY (id),
	CONSTRAINT attachments_attachments_thumbnail FOREIGN KEY (attachment_thumbnail) REFERENCES public.attachments(id) ON DELETE SET NULL,
	CONSTRAINT attachments_items_attachments FOREIGN KEY (item_attachments) REFERENCES public.items(id) ON DELETE CASCADE
);


-- public.auth_roles definition

-- Drop table

-- DROP TABLE public.auth_roles;

CREATE TABLE public.auth_roles (
	id int8 GENERATED BY DEFAULT AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 1 CACHE 1 NO CYCLE) NOT NULL,
	"role" varchar DEFAULT 'user'::character varying NOT NULL,
	auth_tokens_roles uuid NULL,
	CONSTRAINT auth_roles_pkey PRIMARY KEY (id),
	CONSTRAINT auth_roles_auth_tokens_roles FOREIGN KEY (auth_tokens_roles) REFERENCES public.auth_tokens(id) ON DELETE CASCADE
);
CREATE UNIQUE INDEX auth_roles_auth_tokens_roles_key ON public.auth_roles USING btree (auth_tokens_roles);


-- public.item_fields definition

-- Drop table

-- DROP TABLE public.item_fields;

CREATE TABLE public.item_fields (
	id uuid NOT NULL,
	created_at timestamptz NOT NULL,
	updated_at timestamptz NOT NULL,
	"name" varchar NOT NULL,
	description varchar NULL,
	"type" varchar NOT NULL,
	text_value varchar NULL,
	number_value int8 NULL,
	boolean_value bool DEFAULT false NOT NULL,
	time_value timestamptz NOT NULL,
	item_fields uuid NULL,
	CONSTRAINT item_fields_pkey PRIMARY KEY (id),
	CONSTRAINT item_fields_items_fields FOREIGN KEY (item_fields) REFERENCES public.items(id) ON DELETE CASCADE
);
CREATE INDEX idx_item_fields_item_lookup ON public.item_fields USING btree (item_fields, name);
CREATE INDEX idx_item_fields_name_type ON public.item_fields USING btree (name, type);
CREATE INDEX idx_item_fields_number_search ON public.item_fields USING btree (name, number_value) WHERE (number_value IS NOT NULL);
CREATE INDEX idx_item_fields_text_search ON public.item_fields USING btree (name, text_value) WHERE ((text_value IS NOT NULL) AND ((text_value)::text <> ''::text));


-- public.custom_field_analysis source

CREATE OR REPLACE VIEW public.custom_field_analysis
AS SELECT item_fields.name AS field_name,
    item_fields.type AS field_type,
    count(*) AS usage_count,
    count(DISTINCT item_fields.item_fields) AS items_using_field,
    min(item_fields.created_at) AS first_used,
    max(item_fields.updated_at) AS last_updated
   FROM item_fields
  GROUP BY item_fields.name, item_fields.type
  ORDER BY (count(*)) DESC, item_fields.name;